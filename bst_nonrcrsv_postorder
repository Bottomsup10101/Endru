/*
    14 b.) Write a C++ program to create a Binary Search Tree for N nodes, and implement non-
           recursive post-order tree traversal.
*/
#include <iostream>
using namespace std;
const int size=100;
struct node
{
    int data;
    node*left,*right;
    int flag;//for checking whether the node was visited or not if visited fag should be 1 not visited flag should be zero
};

//stack data structure used for storing and manipulation through address of each node
class stack
{
    node*arr[size];//array storing address of each node
    int top;
    public:
    stack(){top=-1;}
    void push(node*t)
    {
        if(top!=size-1)
        {
            arr[++top]=t;
        }
    }
    
    node* pop()
    {
        node*t;
        if(top!=-1)
        {
            t=arr[top--];
        }
        return t;
    }
    
    int IsEmpty()
    {
        if(top==-1)
        return 1;
        else
        return 0;
    }
};

class bst
{
    node*root;
    public:
    bst(){ root=NULL;}
    
    //declaring all function prototype
      void create();
      void disp();
      void nr_post(node*temp);
};

//defining create function
void bst::create()
{
    int n;
    cout<<"\nEnter the number of nodes you want to create in BST: ";
    cin>>n;
    node*temp,*parent,*nn;
    temp=NULL;parent=NULL;
    for(int i=0;i<n;i++)
    {
        nn=new node;
        if(nn==NULL)
        {
            cout<<"\nNo Memory left in the system....";
            cout<<"\nExiting the program";
            return;
        }
        //taking data of node from user
        cout<<"\nEnter the data for "<<i+1<<" node:";
        cin>>nn->data;
        nn->left=NULL;nn->right=NULL;
        
        //creation of first node
        if(i==0)
        {
            root=nn;
            continue;
        }
        temp=root;
        
        //finding correct location for new node 
        while(temp!=NULL)
        {
            parent=temp;
            if(temp->data<nn->data)
            {
                temp=temp->right;
            }
            else
            temp=temp->left;
        }
        
        //checking whether in left or right of parent node
        if(parent->data<nn->data)
        {
            parent->right=nn;
        }
        else
        parent->left=nn;
        
    }
}

//non-recurrsive preorder traversal
void bst::nr_post(node*temp)
{
    stack s1;
    // root left right
    while(temp!=NULL)
    {
        temp->flag=0;
        s1.push(temp);
        temp=temp->left;
        
    }
    
    while(!s1.IsEmpty())
    {
        temp=s1.pop();
        if(temp->flag==0)
        {
            temp->flag=1;
            s1.push(temp);
            temp=temp->right;
            while(temp!=NULL)
            {
                temp->flag=0;
                s1.push(temp);
                temp=temp->left;
            }
        }
            
        else
        cout<<temp->data<<" ";
    }
    
}

//Display function
void bst::disp()
{
   cout<<"\nThe created BST displayed using non-recurrsive postorder traversal below:\n";
   nr_post(root);
}

int main()
{
   bst b;
   b.create();
   b.disp();
}
